# 02.04.2019, Dienstag

## **1. Flexbox**

## **1.1 Flexbox: container**

`display:flex` Beinflussug wie Elements sich im Parentelement verhalten.

`justify-content` kontrolliert die Ausrichtung des Boxinhalts entlang der main/inline Achse. Es definiert also wie der Raum zwischen und um flex items verteilt wird.

`flex-start`, `flex-end`, `center`,

`space-between`, `space-around`, `space-evenly`,

`flex-direction`, `row`, `space-column`,

`align-items`, `flex-start/-end`, `center`, `stretch`

`justify-self: stretch | center | start | end`

- wird in Flexbox ignoriert
- Zentrierung innerhalb der Zelle
- Im block-level richtet es ein item innerhalb dessen blocks an der inline-Achse aus.
- für absolutely-positioned elements richtet es ein item innerhalb dessen blocks an der inline-Achse aus in Abhängigkeit von top, left, bottom und right.

## **1.2 Flexbox: items**

`order` ändert Reihenfolge der Elemente

`align-self`, `flex-grow`, `flex-shrink`, `flex-basis`, `flex: Shortcut`

- `flex-grow:` verteilte Inhalte können sich vergrößern
- `flex-shrink:` verteilte Inhalte können sich verkleinern.
- `flex-shrink:` macht nur Sinn mit width oder height.

- `flex-grow:0` wächst nicht
- `flex-grow:1` wächst
- `flex-grow:2` wächst doppelt zu 1
- `flex-grow:n` wächst mit ^n

- `flex-shrink:0` verteilte Inhalte können nicht kleiner werden als Minimalinhalt:
- eher mit `grid` arbeiten, flex-grow ist speziell.

## **2. CSS: Selectors**

- niemals ID-Selector!

- um gezielt Elemente auszuwählen

- Bsp.: Type, Class, ID, Attribute, State

- erzeugen Pseudo Classes: `hover`, `visited`, `active`

  - Bsp. für Pseudo-Klasse: first-child

- erzeugen Pseudo Elements: `::before`, `::after`

- attribute-selector: z.B. `input[attribute="value"]`

  `[attribute^="value"]` := fängt an mit

  `[attribute$="value"]` := hört auf mit

  `[attribute*="value"]` := kommt Zeichenkette vor?

* type-selectors für base styling: - `body`, `h1`, `strong`, `a`
  überschreiben das default styling des Browers.

* Combinators: Mehrfach Styles - durch Kommatrennung, heute selten genutzt.

* descendant-selector: heute selten

* child-selector: `.tag>li {...}` muss direktes children sein

* combined-selector: `.list>li.active {...}` eine Kombination

weitere: `:disabled`, `:empty`, `:not()`, `:target`, `:nth-of-type()`

## **3. CSS: Position**

Elemente relativ zur "normalen Position" verschieben, absolut zum Parentelement.

`position:static` static := Standard Element-Value

`position:relativ`

`top`, `right`, `bottom`, `left`

`position:absolut`,

`position:fixed` Element ist fix, sonst scroll

`position:sticky` Im Fluss bis durch `position:static` fest.
z.B. für Adressmenü

`position:relativ` wird sehr selten benutzt

`position:absolut` bezieht sich immer auf `position:relativ`, da keine `position:relativ` Beziehung im html.

`z-index:n` f.a. positive, natürliche Zahlen.

Steuert wie weit sich Elemente überlappen.

Negative Zahlen nicht mehr interaktiv.

`z-index: 0 || undef` ist der default-Wert.

`scroll-snap-type:y mandatory` Elemente rasten automatisch ein z.B. bei Slideshow

`overflow-x: scroll` gibt an, wie übergroßer Inhalt im Bezug auf die Breite des Elements behandelt wird. Zudem wird dann `overflow-y` auf `auto` anstatt Standartwert `visible` gesetzt.

## **BEM: Block Element Modifier**

`Block__Element--Modifier`

Vorteile: - Hilft eigenes CSS zu strukturieren - Die Komponenten bilden Namens-Basis - geringe Spezifität

Nachteile: - Kann zu langen Klassennamen führen

### **Sass**

### **CSS: Transform**

teaser: `transform` um absolut positionierte Elemente zu verschieben.

### **CSS: Specificity**

teaser: legt fest, welcher Style gültig ist.

### **CSS: Effects**

`box-shadow: offset-x|offset-y|blur-radius|color`

Negative Values für gegengesetzte Richtung.
Hinzufügen von Schatten durch Kommatrennung.

`box-shadow` `inset` Schatten nach innen
`text-shadow`,
`filter` `blur(4px)` `contrast`
`hue-rotate` Farbkreis drehen
`drop-shadow` für genauere Shadows, z.B. Sprechblase im Gegensatz zu Box
`gradients`, `background-blend-mode`

#### **Keyboard Short Cut des Tages**

`Control` + `Command` + `Space` für Icons im IOS

### **Resources/Info:**

- [FlexFroggy](https://flexboxfroggy.com/#)

- [Egghead](https://egghead.io/)

- [CSS-Tricks](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

- [Sass](https://flukeout.github.io/)

- [Neuefische Slides ](https://neuefische-slides.herokuapp.com/)

- [Select The Plates](https://flukeout.github.io/)

- [Unsplash Random Image](https://source.unsplash.com/random)

- [Fish Image Exercise](https://images.unsplash.com/photo-1520301255226-bf5f144451c1?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=300&q=60)

### **Exercises:**

- [display: flex intro - start](https://codepen.io/neuefische/pen/MRYPRP)

- [Grid: justify-self](https://codepen.io/neuefische/pen/ROPGxe?editors=0100)

- [flex-grow and flex-shrink](https://codepen.io/neuefische/pen/yrNVYb?editors=1100)

- [CSS: position: relative](https://codepen.io/neuefische/pen/dLoOZE?editors=1100)

- [CSS: position: absolute](https://codepen.io/neuefische/pen/YMXpmy?editors=0100)

- [CSS: position: fixed](https://codepen.io/neuefische/pen/pBJREO?editors=0100)

- [CSS: position: sticky](https://codepen.io/neuefische/pen/eoNgwm?editors=1100)

- [Sass intro](https://codepen.io/neuefische/pen/BENdzv)

- [CSS attribute selectors](https://codepen.io/neuefische/pen/zXGPrX?editors=1100)

- [CSS: Checkbox example](https://codepen.io/neuefische/pen/LvVerQ?editors=0100)

- [CSS Pseudo-Elements](https://codepen.io/neuefische/pen/JVdpdZ?editors=1100)

- [CSS: effects](https://codepen.io/neuefische/pen/oOXdVy?editors=1100)

- [CSS Pseudo-Elements](https://codepen.io/neuefische/pen/JVdpdZ?editors=1100)

- [CSS Pseudo-Elements](https://codepen.io/neuefische/pen/JVdpdZ?editors=1100)

* [HTML Wireframe Exercise](https://codesandbox.io/s/m777v5qq2x)

* [HTML Bootstrap Mobile First Website](https://codepen.io/neuefische/pen/EMqKBZ?editors=1000)

### **Tipps & Anmerkungen**

gehen immer zusammen gut:

        .box {
          display: flex
          justify-content: center;
          align-items: center
          }

- Achse verkehrt herum => Dann flex-start und flex-end vertauschen

- justify-content: flex-end => alles rückt ans Ende

- display: flex vs. grid

  - display: flex nur zum Anordnen
  - grid für gröbere Anordnung

Wo ist der Unterschied zwischen `flex-basis:` und `width:`
Beides irgendwie Breite:

Shortcut:
background-image: linear-gradient(color1,color2) => background: gleichmäßiger Verlauf zwischen Farben
linear-gradient erzeugt ein image
=> background: linear-gradient(color1,color2);

Shortcut für flex: => Flex: Shortcut

`flex: flex-grow flex-shrink flex-basis`

`flex: 0 1 auto` ist default

Normalerweise gibt man dem Html-Element keine eigene Farbe.

`opacity: 0.n` Sichtbarkeit

im Mobile gibt es kein `hover`
